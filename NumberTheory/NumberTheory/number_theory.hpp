/**
 * @brief  整数論的アルゴリズムについての物置
 *
 * @note   ここでは、"大きな入力"とは、(ソーティングの場合のような)"多くの整数"を含む入力ではなく、普通は"大きな整数"を含む入力を意味する
 *         したがって、入力における整数の個数ではなく、入力を表現するのに必要なビット数によって入力のサイズを測る
 *         整数入力a1, a2, ..., akをもつアルゴリズムが多項式時間アルゴリズム(polynorminal-time algorithm)であるのは、
 *         実行時間がlga1, lga2, ..., lgakの多項式のとき、すなわち、2進符号化された入力の長さの多項式のときである
 *
 * @note   整数論的アルゴリズムの大部分においては初等算術演算(乗算、除算、剰余計算)を1単位時間の基本演算として考えるのが適切であることがわかる
 *         アルゴリズムで実行されるこのような算術演算の回数をカウントすることにより、コンピュータ上でのアルゴリズムの実際の実行時間を
 *         合理的に推測する基礎が得られる. しかしながら、入力が大きいときには初等演算に時間がかかることがある. したがって、
 *         整数論的アルゴリズムが必要とするビット演算(bit operation)の回数を測定する方が都合が良くなる. このモデルでは、
 *         通常の方法で2個のβビットの整数を乗算するとΘ(β^2)かかる. 同様に、βビットの整数をそれより短い整数で割る演算やβビットの整数を
 *         それより短い整数で割ったときの剰余を求める演算は、単純なアルゴリズムによりΘ(β^2)時間できる. もっと速い方法も知られている
 *         たとえば、2個のβビットの整数を乗算する単純な分割統治法の実行時間はΘ(β^(lg3))であり、現在わかっている最も速い方法の実行時間は
 *         Θ(βlgβlglgβ)である. しかしながら、実用的にはΘ(β^2)の方法が最善であり、解析の基礎としてこの複雑度を用いることにする
 *         ここでは、必要な算術演算の回数とビット演算の回数の両方を用いてアルゴリズムを解析する
 *
 * @date  2016/03/30
 */



//****************************************
// インクルードガード
//****************************************

#ifndef __NUMBER_THEORY_HPP__
#define __NUMBER_THEORY_HPP__



//****************************************
// 必要なヘッダファイルのインクルード
//****************************************

#include <cstdint> 
#include <set>



//****************************************
// オブジェクト形式マクロの定義
//****************************************

//#define NUMBER_THEORY_BEGIN namespace nt {
//#define NUMBER_THEORY_END }



//****************************************
// 型シノニム
//****************************************

using int_t    = std::int64_t;
using uint_t   = std::uint64_t;
using bit_t    = uint_t;
using intset_t = std::set<int_t>;



#endif  // end of __NUMBER_THEORY_H__

