/**
 * @brief  Miller-Rabinの乱択素数判定法
 *
 * @note   Zn+をZnの0以外の要素の集合、すなわち、
 *           Zn+ = { 1, 2, ..., n - 1 }
 *         とする. nが素数ならばZn+ = Zn*である
 *
 *         nが合成数であり、しかも
 *           a^(n-1) ≡ 1 (mod n)  ...(*1)
 *         を満たすとき、nをaを底とする疑似素数(base-a pseudprime)と言う. フェルマの定理から、nが素数ならばnは任意のa ∈ Zn+に対して式(*1)を満たす
 *         したがって、式(*1)を満たさないa ∈ Zn+を発見できれば、nは確かに合成数である. 驚くべきことに、「ほとんど」の場合、この逆も成り立つ
 *         そこで、この基準はほぼ完全な素数判定基準である. nが式(*1)をa = 2のときに満たすかどうかテストする. 成り立たなければ、COMPOSITEを返して
 *         nは合成数であると断言する. 成り立てば、(実は、nは素数か、2を底とする疑似素数のどちらかだが)nを素数であると考えることにしてPRIMを返す
 *         次の手続きはこの方法でnの素数を疑似的に行う. 入力を2より大きい奇数であると仮定する
 *
 *         PSEUDPRIME(n)
 *         1  if MODULAR_EXPONENTION(2, n - 1, n) !≡ 1 (mod n)
 *         2    return COMPOSITE  // 間違いない
 *         3  else return PRIM    // あわよくば
 *
 *         この手続きは間違うことがあるが、間違いは1つの場合にしか起こらない. nを合成数と答えた場合は常に正しい
 *         nが2を底とする疑似素数のときに間違いを犯す
 *
 *         Carmichael(カーマイケル)数(Carmichael number)、すなわち、すべてのa ∈ Zn*に対して式(*1)を満たす合成数nが存在するので、残念ながら、
 *         別の底の候補、たとえば、a = 3を選んで式(*1)をテストするだけではすべての間違いを除去できない. (gcd(a, n) > 1のとき、すなわち、
 *         a !∈ Zn*のとき、式(*1)は確かに成立しない. しかし、大きい素因数だけからnが構成されているときにはgcd(a, n) > 1を満たすaを発見することは
 *         非常に困難であり、このようなaを発見し、nが合成数であることを示そうとする試みに期待することはできない)
 *         最初の3個のCarmichael数は561, 1105, 1729である. Carmichael数は非常に少なく、たとえば、100,000,000までにたったの255個しか存在しない
 *         Carmichael数に騙されないように上記の素数判定法を改良する方法を以下に示す
 *
 *         単純な判定法であるPSEUDPRIMEに2つの修正を施すことによって、Miller-Rabinの素数判定法(Miller-Rabin randomized prime test)はその問題点を解決する
 *
 *         * 底aとして、1つの値だけではなく、ランダムに選択した複数の値を示す
 *         * 各べき乗剰余を計算しているとき、最終のべき乗剰余を得るまでの間、法nの下で非自明な1の平方根をずっと探し続ける
 *           発見すれば、終了してCOMPOSITEを返す
 *
 * @date   2016/04/29
 */



//****************************************
// インクルードガード
//****************************************

#ifndef __MILLER_RABIN_HPP__
#define __MILLER_RABIN_HPP__



//****************************************
// 必要なヘッダファイルのインクルード
//****************************************

#include "../NumberTheory/number_theory.hpp"



//****************************************
// 関数の宣言
//****************************************

bool miller_rabin(int_t n);



#endif  // end of __MILLER_RABIN_HPP__

