/**
 * @brief  マージソートのマルチスレッド化
 * @date   2016/03/06
 */



//****************************************
// 必要なヘッダファイルのインクルード
//****************************************

#ifndef __cilk
#include <cilk/cilk_stub.h>
#endif
#include <cilk/cilk.h>
#include <cilk/cilk_api.h>
#include <cstdint>
#include <vector>
#include <iostream>
#include <random>
#include <algorithm>



//****************************************
// 型シノニム
//****************************************

using elem_t  = std::int32_t;
using array_t = elem_t*;
using index_t = std::int32_t;



//****************************************
// 関数の定義
//****************************************

/**
 * @brief  2分探索を行う
 *
 * @note   手続きBINARY-SEARCH(x, T, p, r)はキーxと部分配列T[p..r]を入力として、次のうちのひとつを返す
 *
 *         ・ T[p..r]が空(r < p)なら、添字pを返す
 *         ・ x <= T[p]であって、xがT[p..r]の任意の要素よりも大きくないなら、添字pを返す
 *         ・ x >  T[p]のとき、p < q <= r + 1の中で、T[q - 1] < x を満たす最大の添字qを返す
 */
index_t bsearch(elem_t x, array_t T, index_t p, index_t r)
{
    index_t low  = p;
    index_t high = std::max(p, r + 1);

    while (low < high) {
        index_t mid = low + (high - low) / 2;  // オーバーフロー対策
        if (x <= T[mid]) { high = mid; }
        else             { low  = mid + 1; }
    }
    return high;
}


/**
 * @brief マルチスレッドマージ手続き
 *
 * @note  マルチスレッド化されたマージを導出するための分割統治戦略は、配列Tの部分配列上で動作する
 *        長さn1 = r1 - p1 + 1のソート済み部分配列T[p1..r1]と長さn2 = r2 - p2 + 1のソート済み部分配列T[p2..r2]をマージして、
 *        長さn3 = r3 - p3 + 1 = n1 + n2の部分配列A[p3..r3]に格納することを考える. 簡単化のために、一般性を失うことなくn1 >= n2を仮定する
 *
 * @note  まず、部分配列T[p1..r1]の真ん中の要素x = T[q1]を求める. ここで、q1 = floor((p1 + r1) / 2)である
 *        この部分配列はソート済みだから、xはT[p1..r1]の中央値である. すなわち、T[p1..q1-1]のすべての要素はx以下だし、T[q1+1..r1]のすべての要素はx以上である
 *        そして、2分探索を用いて、部分配列T[p2..r2]の中で、T[q2-1]とT[q2]の間にxを挿入しても部分配列が正しくソートされているような添字q2を発見する
 *        次に、部分配列T[p1..r1]とT[p2..r2]をマージして、以下の要領でA[p3..r3]に格納する
 *
 *          1. q3 = p3 + (q1 - p1) + (q2 - p2)とする
 *          2. xをA[q3]にコピーする
 *          3. 再帰的にT[p1..q1-1]とT[p2..q2-1]をマージし、結果を部分配列A[p3..q3-1]に置く
 *          4. 再帰的にT[q1+1..r1]とT[q2..r2]をマージし、その結果を部分配列A[q3+1..r3]に置く
 *
 *        q3の計算において、q1 - p1は部分配列T[p1..q1-1]の要素数、q2 - p2は部分配列[p2..q2-1]の要素数だから、
 *        その和は部分配列A[p3..r3]においてxより前に来る要素数である
 *
 * @note  基底はn1 = n2 = 0の場合である. このとき、2つのからの部分配列をマージするのに仕事をする必要はない
 *        部分配列T[p1..r1]の長さはT[p2..r2]の長さ以上であると仮定した. すなわちn1 >= n2だから、n1 = 0を判定することで基底が判定できる
 *        2つの部分配列中の1つだけが空である場合、すなわち、仮定n1 >= n2から、部分配列T[p2..r2]だけが空である場合についても
 *        再帰が正しく働くことを保証する必要がある
 *
 * @note  MERGEとは異なり、P-MERGEではマージする部分配列は配列の中で隣接しているとは仮定しない(すなわち、P-MERGEではp2 = r1 + 1とは限らない)
 *        MERGEとP-MERGEの別の相違は、P-MERGEではマージした列を蓄えるための出力用部分配列Aを引数としてとることである
 *        P-MERGE(T, p1, r1, p2, r2, A, p3)を呼び出すと、ソート済み部分配列T[p1..r1]とT[p2..r2]とマージして部分配列A[p3..r3]に格納する
 *        ここで、r3 = p3 + (r1 - p1 + 1) + (r2 - p2 + 1) - 1 = p3 + (r1 - p1) + (r2 - p2) + 1であり、これは入力として与えられていない
 *
 * @note  n個の要素に対するP-MERGEのスパンPM∞(n) = Θ((lg^2)n)であり、最悪時の仕事量PM1(n) = Θ(n)であるから、
 *        P-MERGEの並列度はPM1(n)/PM∞(n) = Θ(n / ((lg^2)n))である
 */
void pmerge(array_t T, index_t p1, index_t r1, index_t p2, index_t r2, array_t A, index_t p3)
{
    index_t n1 = r1 - p1 + 1;  // 部分配列T[p1..r1]の長さn1と
    index_t n2 = r2 - p2 + 1;  // T[p2..r2]の長さn2を求める

    if (n1 < n2) {  // n1 >= n2を保証するため、(必要ならば)変数を置き換える
        std::swap(p1, p2);  // p1とp2を交換する
        std::swap(r1, r2);  // r1とr2を交換する
        std::swap(n1, n2);  // n1とn2を交換する
    }

    // 基底判定を行う
    if (n1 == 0) {  // 基底のとき(n1 = 0のとき)、
        return;     // 部分配列T[p1..r1]もT[p2..r2]も空だから、何もせず、手続きから戻る
    }
    // 分割統治戦略を実現する
    else {
        // T[p1..r1]の中央の要素を計算し、
        index_t q1 = p1 + (r1 - p1) / 2;
        // T[p2..r2]の添字q2で、T[p2..q2-1]のすべての要素が(xに対応する)T[q1]以下、T[q2..r2]のすべての要素がT[q1]以上となるものを求める
        index_t q2 = bsearch(T[q1], T, p2, r2);
        // 出力用部分配列A[p3..r3]をA[p3..q3-1]とA[q3+1..r3]に分割する添字q3を計算し、
        index_t q3 = p3 + (q1 - p1) + (q2 - p2);
        // T[q1]を直接A[q3]にコピーする
        A[q3] = T[q1];

        // つぎに、入れ子並列性を用いて再帰を行う
        cilk_spawn pmerge(T, p1, q1 - 1, p2, q2 - 1, A, p3);  // 最初の部分問題を生成し、
        pmerge(T, q1 + 1, r1, q2, r2, A, q3 + 1);             // 2番目の部分問題を並列に呼び出す
        cilk_sync;                                            // これらの部分問題が確かに完了した後で手続きから戻ることを保証する

        // NOTE : すべての手続きは、明示的にsyncを指示しなくても、最後にsyncを実行してから戻ることになっているので、
        //        省略してもよいが、プログラミング作法としては置いておくほうが望ましい
    }

    // NOTE : 部分配列T[p2..r2]が空のときにも正しく働くことを保証するために、多少の工夫が施されている. すなわち、
    //        各再帰呼び出しにおいて、T[p1..r1]が最終的に空になって基底処理に進むまで、この配列の中央値を出力用配列の上に置く
}


/**
 * @brief マルチスレッドマージソート
 *
 * @note  このマージソートは引数として出力用部分配列Bを取り、そこにソート結果を格納する
 *        特に、呼び出しP-MERGE-SORT(A, p, r, B, s)はA[p..r]の要素をソートし、結果をB[s..s + r - p]に格納する
 *
 * @note  P-MERGE-SORTの仕事量PMS1(n) = Θ(nlgn)であり、最悪時のスパンPMS∞(n) = Θ((lg^3)n)である
 *        したがって、P-MERGE-SORTの並列度はPMS1(n) / PMS∞(n) = Θ(nlgn) / Θ((lg^3)n) = Θ(n / ((lg^2)n))であり、
 *        理論上でも実際上でも格段に優れている
 */

void pmsort(array_t A, index_t p, index_t r, array_t B, index_t s)
{
    index_t n = r - p + 1;  // 入力の部分配列A[p..r]の要素数nを計算した後、
    if (n == 1) {           // 基底、すなわち、配列が1個の要素しか持たない場合を扱う
        B[s] = A[p];
    }
    else {
        // 並列に実行する再帰生成と再帰呼出しの準備をする
        std::vector<elem_t> T(n + 1);      // 再帰マージソートの結果を格納するn個の要素を持つ一時配列Tを割り当てる
        index_t q  = p + (r - p) / 2;      // A[p..r]の要素を2つの部分配列A[p..q]とA[q+1..r](これらは再帰的にソートされる)に分割する添字qを計算し、
        index_t q_ = q - p + 1;            // qを用いて、部分配列A[p..q]の要素数q_を計算する.

        // この時点で、
        cilk_spawn pmsort(A, p, q, &T[0], 1);   // 手続き生成と
        pmsort(A, q + 1, r, &T[0], q_ + 1);     // 再帰呼出しを実行する
        cilk_sync;                              // 生成された手続きが終了するまで手続きを中断する

        // 最後に、ソート済み部分配列T[1..q]とT[q+1_..n]をマージし、
        pmerge(&T[0], 1, q_, q_ + 1, n, B, s);  // その結果を出力用部分配列B[s..s + r - p]に格納するためにP-MERGEを呼び出す
    }
}


int main()
{
    std::random_device rd;
    std::mt19937 mt(rd());

    const index_t N = 1023;
    const elem_t  M = 4096;
    std::vector<elem_t> A(N + 1);
    for (index_t i = 1; i <= N; i++) {
        A[i] = mt() % M;
    }

    __cilkrts_set_param("nworkers", "4");

    std::vector<elem_t> B(N + 1);
    pmsort(&A[0], 1, N, &B[0], 1);

    for (index_t i = 1; i <= N; i++) {
        std::cout << B[i] << " ";
    }
    std::cout << std::endl;

    getchar();
    return 0;
}

